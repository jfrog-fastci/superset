/**
 * AgentManager â€” manages StreamWatchers for sessions that are explicitly
 * requested via ensureRuntime/ensureWatcher.
 *
 * Session runtime readiness is now opt-in and request-driven. The manager no
 * longer depends on session_hosts subscriptions for send-time behavior.
 */

import { setAnthropicAuthToken } from "@superset/agent";
import { db } from "@superset/db/client";
import { chatSessions, workspaces } from "@superset/db/schema";
import { eq } from "drizzle-orm";
import {
	getCredentialsFromConfig,
	getCredentialsFromKeychain,
} from "../../auth/anthropic";
import {
	sessionAbortControllers,
	sessionContext,
	sessionRunIds,
} from "./session-state";
import { StreamWatcher } from "./stream-watcher";

export interface AgentManagerConfig {
	deviceId: string;
	organizationId: string;
	authToken: string;
	apiUrl: string;
}

export class AgentManager {
	private watchers = new Map<string, StreamWatcher>();
	private startingWatchers = new Map<string, Promise<StreamWatcher>>();
	private deviceId: string;
	private organizationId: string;
	private authToken: string;
	private apiUrl: string;

	constructor(config: AgentManagerConfig) {
		this.deviceId = config.deviceId;
		this.organizationId = config.organizationId;
		this.authToken = config.authToken;
		this.apiUrl = config.apiUrl;
	}

	async start(): Promise<void> {
		// Initialize Claude credentials
		const cliCredentials =
			getCredentialsFromConfig() ?? getCredentialsFromKeychain();
		if (cliCredentials?.kind === "oauth") {
			setAnthropicAuthToken(cliCredentials.apiKey);
			console.log(
				`[agent-manager] Using Claude OAuth credentials from ${cliCredentials.source}`,
			);
		} else if (cliCredentials) {
			console.warn(
				`[agent-manager] Ignoring non-OAuth credentials from ${cliCredentials.source}`,
			);
		}

		console.log(
			`[agent-manager] Starting for org=${this.organizationId} device=${this.deviceId}`,
		);
	}

	hasWatcher(sessionId: string): boolean {
		return this.watchers.has(sessionId);
	}

	async ensureWatcher(
		sessionId: string,
	): Promise<{ ready: boolean; reason?: string }> {
		const existing = this.watchers.get(sessionId);
		if (existing) {
			try {
				await existing.start();
				return { ready: true };
			} catch (err) {
				return {
					ready: false,
					reason: err instanceof Error ? err.message : String(err),
				};
			}
		}

		const inFlight = this.startingWatchers.get(sessionId);
		if (inFlight) {
			try {
				const watcher = await inFlight;
				this.watchers.set(sessionId, watcher);
				return { ready: true };
			} catch (err) {
				return {
					ready: false,
					reason: err instanceof Error ? err.message : String(err),
				};
			}
		}

		const startPromise = this.createStartedWatcher(sessionId);
		this.startingWatchers.set(sessionId, startPromise);
		try {
			const watcher = await startPromise;
			this.watchers.set(sessionId, watcher);
			this.logActiveSessions();
			return { ready: true };
		} catch (err) {
			return {
				ready: false,
				reason: err instanceof Error ? err.message : String(err),
			};
		} finally {
			this.startingWatchers.delete(sessionId);
		}
	}

	private async createStartedWatcher(
		sessionId: string,
	): Promise<StreamWatcher> {
		const cwd = await this.resolveCwd(sessionId);
		const watcher = new StreamWatcher({
			sessionId,
			authToken: this.authToken,
			apiUrl: this.apiUrl,
			cwd,
		});
		try {
			await watcher.start();
			return watcher;
		} catch (err) {
			watcher.stop();
			throw err;
		}
	}

	private async resolveCwd(sessionId: string): Promise<string> {
		try {
			const session = await db.query.chatSessions.findFirst({
				where: eq(chatSessions.id, sessionId),
				columns: { workspaceId: true },
			});

			if (session?.workspaceId) {
				const workspace = await db.query.workspaces.findFirst({
					where: eq(workspaces.id, session.workspaceId),
					columns: { config: true },
				});

				if (workspace?.config && "path" in workspace.config) {
					return workspace.config.path;
				}
			}
		} catch (err) {
			console.warn(
				`[agent-manager] Could not resolve workspace path for ${sessionId}:`,
				err,
			);
		}

		return process.env.HOME ?? "/";
	}

	private cleanupSession(sessionId: string): void {
		const controller = sessionAbortControllers.get(sessionId);
		if (controller) controller.abort();
		sessionAbortControllers.delete(sessionId);
		sessionRunIds.delete(sessionId);
		sessionContext.delete(sessionId);
	}

	private logActiveSessions(): void {
		const ids = [...this.watchers.keys()];
		console.log(
			`[agent-manager] Active sessions (${ids.length}): ${ids.join(", ") || "none"}`,
		);
	}

	stop(): void {
		for (const [sessionId, watcher] of this.watchers) {
			watcher.stop();
			this.cleanupSession(sessionId);
		}
		this.watchers.clear();
		this.startingWatchers.clear();
		this.logActiveSessions();
	}

	async restart(options: {
		organizationId: string;
		deviceId?: string;
		authToken?: string;
	}): Promise<void> {
		this.stop();
		this.organizationId = options.organizationId;
		if (options.deviceId) this.deviceId = options.deviceId;
		if (options.authToken) this.authToken = options.authToken;
		await this.start();
	}
}
